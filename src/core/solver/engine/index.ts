import { EventEmitter } from "node:events"

import { Collector, Executor, Process } from "@/src/core"
import { Collection, Execution, Network } from "@/src/lib"

export * from "./config"

export class Engine<
	TCollector extends Collector<string, any>,
	TExecutor extends Executor<`${string}Execution`, any>,
	TCollection extends Collection<TCollector>,
	TExecution extends Execution<TExecutor>,
	TProcesses extends Record<
		string,
		Process<TCollector, TExecutor, TCollection, TExecution>
	>
> {
	constructor(
		public readonly network: Network,
		public readonly processes: TProcesses,
		public readonly stream: EventEmitter,
		public retries: number = 3,
		public delay = 1000
	) {
		console.info(
			`Engine initialized with ${network.collectors.length} collectors, ${
				network.executors.length
			} executors, and ${Object.keys(processes).length} processes.`
		)
	}

	restart = (error: unknown) => {
		console.error(
			`Engine failed while running: ${
				error instanceof Error ? error.message : error
			}`
		)

		if (this.retries === 0) {
			console.error("Engine has no more retries left. Exiting process.")
			return
		}

		console.warn(
			`Engine will retry in ${this.delay / 1000} seconds: ${
				this.retries
			} attempts left.`
		)

		this.retries -= 1

		// * Run the Process again.
		setTimeout(async () => await this.run(), this.delay)
	}

	run = async () => {
		try {
			// ! Catch actions that are generated by collected events.
			// ! This is run first so that we always have Executors
			//   listening for actions when the collectors start.
			const executorsPromise = this.network.executors.map(
				async executor =>
					this.stream.on(executor.key, async action => {
						await executor.execute(action)
					})
			)

			const processesPromises = Object.entries(this.processes).map(
				async ([name, process]) => {
					console.info(`Running Process: ${name}`)

					// ! If the process does not have a processCollection method
					//  then we don't need to do anything and can move on to the next.
					if (process.processCollection === undefined) return

					// ! Initialize the backfilled state.
					if (process.syncState) await process.syncState()

					// ! Catch and process events as they arrive from the collectors.
					// * Will emit:
					//   | 'Execution', ['Log', { ... }]
					//   | 'Execution', ['SubmitTransaction', { ... }]
					// ? We use `Collection` as the key because this map is only creating
					//   a hook per process rather than hook per connector per process.
					//   That is not needed for Executors though because we assume them to
					//   be optimistic which means if we are sending an Execution, it is
					//   always meant to be run with the body that is provided, thus,
					//   we can listen for the key of the Execution rather than `Execution`.
					this.stream.on(
						"Collection",
						async ({
							key,
							collection
						}: {
							key: TCollector["key"]
							collection: Parameters<TCollector["emit"]>[1]
						}) => {
							// * A process will always consume the collection however
							//   that does not mean it will always be used. If there
							//   is an action that needs to be taken, then we plan
							//   on passing that to the configured Executors and if there
							//   is no action to take we will go back to waiting for
							//   future messages to arrive.
							const execution = await process.processCollection(
								key,
								collection
							)

							// * If the process doesn't emit an action then
							//   we don't need to do anything and resume listening.
							if (execution === undefined) return

							// * Pass the need for Execution to the Executors.
							this.stream.emit(execution.key, execution.execution)
						}
					)
				}
			)

			// ! Sends events that are caught by the processes.
			// * Will emit:
			//   | 'Collection', ['NewBlock', { ... }]
			//   | 'Collection', ['PlugIntent', { ... }]
			//   | 'Collection', ['OpenseaOrder', { ... }]
			const collectorsPromises = this.network.collectors.map(
				async collector =>
					await collector.getCollectionStream(this.stream)
			)

			await Promise.all([
				...collectorsPromises,
				...executorsPromise,
				...processesPromises
			])
		} catch (error: unknown) {
			this.restart(error)
		}
	}
}
